diff -urN MPlayer-1.0pre5/libao2/ao_pcmsplt.c MPlayer-1.0pre5-orig/libao2/ao_pcmsplt.c
--- MPlayer-1.0pre5/libao2/ao_pcmsplt.c	1970-01-01 01:00:00.000000000 +0100
+++ MPlayer-1.0pre5-orig/libao2/ao_pcmsplt.c	2004-11-06 15:17:29.852357504 +0100
@@ -0,0 +1,213 @@
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include "bswap.h"
+#include "afmt.h"
+#include "audio_out.h"
+#include "audio_out_internal.h"
+
+static ao_info_t info =
+{
+       "RAW PCM/WAVE file writer audio output with 1h split",
+       "pcmsplt",
+       "adasi",
+       ""
+};
+
+LIBAO_EXTERN(pcmsplt)
+
+extern int vo_pts;
+
+char *ao_outputfileprefix = NULL;
+
+#define WAV_ID_RIFF 0x46464952 /* "RIFF" */
+#define WAV_ID_WAVE 0x45564157 /* "WAVE" */
+#define WAV_ID_FMT  0x20746d66 /* "fmt " */
+#define WAV_ID_DATA 0x61746164 /* "data" */
+#define WAV_ID_PCM  0x0001
+
+struct WaveHeader
+{
+       uint32_t riff;
+       uint32_t file_length;
+       uint32_t wave;
+       uint32_t fmt;
+       uint32_t fmt_length;
+       uint16_t fmt_tag;
+       uint16_t channels;
+       uint32_t sample_rate;
+       uint32_t bytes_per_second;
+       uint16_t block_align;
+       uint16_t bits;
+       uint32_t data;
+       uint32_t data_length;
+};
+
+/* init with default values */
+static struct WaveHeader wavhdr = {
+       le2me_32(WAV_ID_RIFF),
+        /* same conventions than in sox/wav.c/wavwritehdr() */
+       0, //le2me_32(0x7ffff024),
+       le2me_32(WAV_ID_WAVE),
+       le2me_32(WAV_ID_FMT),
+       le2me_32(16),
+       le2me_16(WAV_ID_PCM),
+       le2me_16(2),
+       le2me_32(44100),
+       le2me_32(192000),
+       le2me_16(4),
+       le2me_16(16),
+       le2me_32(WAV_ID_DATA),
+       0, //le2me_32(0x7ffff000)
+};
+
+static FILE *fp = NULL;
+static int mlength = 1024*1024*50;
+// to set/get/query special features/parameters
+static int control(int cmd,void *arg){
+    return -1;
+}
+static void open_ofile()
+{
+        char tmp1[200], tmp2[200];
+        time_t tt;
+        tt=time(NULL);
+        strftime (tmp1,200,"%F-%H-%M-%S",gmtime(&tt));
+        snprintf(tmp2, 200, "%s-%s.wav", ao_outputfileprefix,tmp1);
+        fp = fopen(tmp2, "wb");
+        if(fp) {
+               fwrite(&wavhdr,sizeof(wavhdr),1,fp);
+               wavhdr.file_length=wavhdr.data_length=0;
+       }
+}
+static void close_ofile()
+{
+       if(fseek(fp, 0, SEEK_SET) == 0){ /* Write wave header */
+               wavhdr.file_length = wavhdr.data_length + sizeof(wavhdr) - 8;
+               wavhdr.file_length = le2me_32(wavhdr.file_length);
+               wavhdr.data_length = le2me_32(wavhdr.data_length);
+               fwrite(&wavhdr,sizeof(wavhdr),1,fp);
+       }
+       fclose(fp);
+}
+
+
+// open & setup audio device
+// return: 1=success 0=fail
+static int init(int rate,int channels,int format,int flags){
+       int bits;
+       if(!ao_outputfileprefix)
+               ao_outputfileprefix = strdup("audiodump");
+
+       /* bits is only equal to format if (format == 8) or (format == 16);
+          this means that the following "if" is a kludge and should
+          really be a switch to be correct in all cases */
+
+       bits=8;
+       switch(format){
+       case AFMT_S8:
+           format=AFMT_U8;
+       case AFMT_U8:
+           break;
+       default:
+           format=AFMT_S16_LE;
+           bits=16;
+           break;
+       }
+       if(ao_subdevice && (atoi(ao_subdevice)>0) )
+         mlength=atoi(ao_subdevice)*1024*1024;
+       ao_data.outburst = 65536;
+       ao_data.buffersize= 2*65536;
+       ao_data.channels=channels;
+       ao_data.samplerate=rate;
+       ao_data.format=format;
+       ao_data.bps=channels*rate*(bits/8);
+
+       wavhdr.channels = le2me_16(ao_data.channels);
+       wavhdr.sample_rate = le2me_32(ao_data.samplerate);
+       wavhdr.bytes_per_second = le2me_32(ao_data.bps);
+       wavhdr.bits = le2me_16(bits);
+
+       wavhdr.data_length=le2me_32(0x7ffff000);
+       wavhdr.file_length = wavhdr.data_length + sizeof(wavhdr) - 8;
+
+       open_ofile();
+        if(fp) return 1;
+       return 0;
+}
+
+// close audio device
+static void uninit(int immed){
+      close_ofile();
+}
+
+// stop playing and empty buffers (for seeking/pause)
+static void reset(){
+
+}
+
+// stop playing, keep buffers (for pause)
+static void audio_pause()
+{
+    // for now, just call reset();
+    reset();
+}
+
+static void switch_ofile()
+{
+close_ofile();
+open_ofile();
+}
+// resume playing, after audio_pause()
+static void audio_resume()
+{
+}
+
+// return: how many bytes can be played without blocking
+static int get_space(){
+
+    if(vo_pts)
+      return ao_data.pts < vo_pts ? ao_data.outburst : 0;
+    return ao_data.outburst;
+}
+
+// plays 'len' bytes of 'data'
+// it should round it down to outburst*n
+// return: number of bytes played
+static int play(void* data,int len,int flags){
+
+// let libaf to do the conversion...
+#if 0
+//#ifdef WORDS_BIGENDIAN
+       if (ao_data.format == AFMT_S16_LE) {
+         unsigned short *buffer = (unsigned short *) data;
+         register int i;
+         for(i = 0; i < len/2; ++i) {
+           buffer[i] = le2me_16(buffer[i]);
+         }
+       }
+#endif
+
+       //printf("PCM: Writing chunk!\n");
+       fwrite(data,len,1,fp);
+
+       wavhdr.data_length += len;
+        if (wavhdr.data_length>mlength)
+                switch_ofile();
+       return len;
+}
+
+// return: delay in seconds between first and last sample in buffer
+static float get_delay(){
+
+    return 0.0;
+}
+
+
+
+
+
+
diff -urN MPlayer-1.0pre5/libao2/Makefile MPlayer-1.0pre5-orig/libao2/Makefile
--- MPlayer-1.0pre5/libao2/Makefile	2004-06-25 20:11:13.000000000 +0200
+++ MPlayer-1.0pre5-orig/libao2/Makefile	2004-11-06 15:17:29.853357352 +0100
@@ -2,7 +2,7 @@
 
 LIBNAME = libao2.a
 
-SRCS=afmt.c audio_out.c ao_mpegpes.c ao_null.c ao_pcm.c ao_plugin.c pl_delay.c pl_format.c pl_surround.c remez.c pl_resample.c pl_volume.c pl_extrastereo.c pl_volnorm.c pl_eq.c $(OPTIONAL_SRCS)
+SRCS=afmt.c audio_out.c ao_mpegpes.c ao_null.c ao_pcmsplt.c ao_pcm.c ao_plugin.c pl_delay.c pl_format.c pl_surround.c remez.c pl_resample.c pl_volume.c pl_extrastereo.c pl_volnorm.c pl_eq.c $(OPTIONAL_SRCS)
 
 OBJS=$(SRCS:.c=.o)
 
--- MPlayer-1.0pre5/libao2/audio_out.c~	2004-11-06 16:12:38.331392240 +0100
+++ MPlayer-1.0pre5/libao2/audio_out.c	2004-11-06 16:12:38.331392240 +0100
@@ -58,6 +58,7 @@
 #endif
 extern ao_functions_t audio_out_mpegpes;
 extern ao_functions_t audio_out_pcm;
+extern ao_functions_t audio_out_pcmsplt;
 extern ao_functions_t audio_out_pss;
 extern ao_functions_t audio_out_plugin;
 
@@ -112,6 +113,7 @@
         &audio_out_null,
 // should not be auto-selected:
 	&audio_out_pcm,
+	&audio_out_pcmsplt,
 	&audio_out_plugin,
 	NULL
 };
