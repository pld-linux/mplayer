--- Makefile	29 Dec 2005 18:01:22 -0000	1.334
+++ Makefile	1 Jan 2006 08:45:36 -0000
@@ -210,7 +210,9 @@ endif
 ifeq ($(TREMOR),yes)
 PARTS += tremor
 endif
-
+ifeq ($(HAVE_XVMC_ACCEL),yes)
+CODEC_LIBS += $(X_LIB)
+endif
 ALL_PRG = $(PRG)
 ifeq ($(MENCODER),yes)
 ALL_PRG += $(PRG_MENCODER)
--- codec-cfg.c	7 Dec 2005 05:12:07 -0000	1.123
+++ codec-cfg.c	1 Jan 2006 08:45:36 -0000
@@ -171,6 +171,7 @@ static int add_to_format(char *s, char *
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
--- configure	30 Dec 2005 05:15:26 -0000	1.1116
+++ configure	1 Jan 2006 08:45:38 -0000
@@ -388,7 +388,8 @@ multiple paths separated by ':'):
   --with-xmmslibdir=DIR    libxmms.so.1 in DIR
   --with-cdparanoiaincdir=DIR  cdparanoia headers in DIR (*)
   --with-cdparanoialibdir=DIR  cdparanoia libraries (libcdda_*) in DIR (*)
-  --with-xvmclib=NAME      name of adapter-specific library (e.g. XvMCNVIDIA)
+  --with-xvmclib=NAME      name of adapter-specific library
+                           (e.g. XvMCNVIDIA/I810XvMC/viaXvMC/viaXvMCPro)
   --with-termcaplib=NAME   name of library with termcap functionality
                            name should be given without leading "lib"
                            checks for "termcap" and "tinfo"
@@ -1448,7 +1449,7 @@ EOF
 cc_check -pipe && _pipe="-pipe" && echores "yes" || echores "no"
 
 _prefix="/usr/local"
-_xvmclib="XvMCNVIDIA"
+_xvmclib=""
 
 # GOTCHA: the variables below defines the default behavior for autodetection
 # and have - unless stated otherwise - at least 2 states : yes no
@@ -3719,31 +3720,88 @@ fi
 echores "$_xv"
 
 
-echocheck "XvMC"
-if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
-  _xvmc=no
-  cat > $TMPC <<EOF
-#include <X11/Xlib.h>
+xvmc_check()
+{
+  if test "$_xvmcvld" = yes; then
+    _xvmcinc="vldXvMC.h"
+  else
+    _xvmcinc="XvMClib.h"
+  fi
+
+  echo "#include <X11/Xlib.h>
 #include <X11/extensions/Xvlib.h>
-#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/$_xvmcinc>
 int main(void) { 
   (void) XvMCQueryExtension(0,0,0);
   (void) XvMCCreateContext(0,0,0,0,0,0,0);
-  return 0; }
-EOF
-  cc_check $_inc_x11 -lXvMC -l$_xvmclib $_ld_xv $_ld_x11 && _xvmc=yes
-fi
-if test "$_xvmc" = yes ; then
-  _def_xvmc='#define HAVE_XVMC 1'
-  _ld_xvmc="-lXvMC -l$_xvmclib"
-  _vosrc="$_vosrc vo_xvmc.c"
-  _vomodules="xvmc $_vomodules"
-else
-  _def_xvmc='#undef HAVE_XVMC'
-  _novomodules="xvmc $_novomodules"
-fi
-echores "$_xvmc"
+  return 0; }" > $TMPC
+
+  _success=0
+  cc_check $_inc_x11 -lXvMC -l$_xvmclib $_ld_xv $_ld_x11 && _success=1
+  return $_ok
+}
 
+# Note: here we try to determine what xvmc capability is available
+# if the xvmc wrapper is available then we link to that, also we
+# check whether we can include the vld (slice) level xvmc include file
+if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
+  _xvmc=no
+
+# No explicit xvmc lib specified so try and find one
+  if test "$_xvmclib" = ""; then
+# Try with the xvmc wrapper+vld first
+    echocheck "XvMC (Wrapper+vld)"
+    _xvmclib="XvMCW"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+# Try with the xvmc wrapper
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (Wrapper)"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+
+# Try with the nvidia lib
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (NVIDIA)"
+      _xvmclib="XvMCNVIDIA"
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  else
+# check for specified xvmc lib
+    echocheck "XvMC vld+("$_xvmclib")"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC ("$_xvmclib")"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  fi
+
+  if test "$_xvmc" = yes ; then
+    _def_xvmc='#define HAVE_XVMC 1'
+    _ld_xvmc="-lXvMC -l$_xvmclib"
+    _vosrc="$_vosrc vo_xvmc.c"
+    _vomodules="xvmc $_vomodules"
+  else
+    _novomodules="xvmc $_novomodules"
+    _def_xvmc='#undef HAVE_XVMC'
+  fi
+
+  if test "$_xvmcvld" = yes; then
+    _def_xvmc_vld='#define HAVE_XVMC_VLD 1'
+  else
+    _def_xvmc_vld='#undef HAVE_XVMC_VLD'
+  fi
+fi
 
 echocheck "Xinerama"
 if test "$_x11" = yes && test "$_xinerama" != no ; then
@@ -7897,6 +7955,7 @@ $_def_vis	// only define if you have VIS
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xvmc_vld
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
--- xvmc_render.h	25 Aug 2003 21:40:35 -0000	1.3
+++ xvmc_render.h	1 Jan 2006 08:45:38 -0000
@@ -5,6 +5,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulate this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -27,7 +30,20 @@ typedef   struct{
   int idct;//does we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+
+#ifdef HAVE_XVMC_VLD
+  int reserved1[3];
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int   slice_code; 
+  int   slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#else
   int reserved1[12];//future extenstions (e.g. gmc,qpel)
+#endif
+  
   void * p_osd_target_surface_render;//pointer to the surface where subpicture is rendered
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
@@ -47,4 +63,6 @@ typedef   struct{
   
   int next_free_data_block_num;//used in add_mv_block, pointer to next free block
 
+
+
 } xvmc_render_state_t;
--- etc/codecs.conf	31 Dec 2005 18:24:00 -0000	1.443
+++ etc/codecs.conf	1 Jan 2006 08:45:39 -0000
@@ -90,6 +90,7 @@ videocodec ffmpeg12mc
   fourcc VCR2
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
--- libmpcodecs/img_format.c	11 Aug 2004 01:41:43 -0000	1.11
+++ libmpcodecs/img_format.c	1 Jan 2006 08:45:39 -0000
@@ -64,6 +64,7 @@ char *vo_format_name(int format)
 	case IMGFMT_ZRMJPEGIB: return("Zoran MJPEG bottom field first");
 	case IMGFMT_XVMC_MOCO_MPEG2: return("MPEG1/2 Motion Compensation");
 	case IMGFMT_XVMC_IDCT_MPEG2: return("MPEG1/2 Motion Compensation and IDCT");
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     return("Unknown");
 }
--- libmpcodecs/img_format.h	11 Aug 2004 01:41:43 -0000	1.16
+++ libmpcodecs/img_format.h	1 Jan 2006 08:45:39 -0000
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
--- libmpcodecs/vd_ffmpeg.c	19 Dec 2005 19:38:28 -0000	1.156
+++ libmpcodecs/vd_ffmpeg.c	1 Jan 2006 08:45:39 -0000
@@ -182,6 +182,8 @@ static int control(sh_video_t *sh,int cm
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
 #endif
 	}
         return CONTROL_FALSE;
@@ -566,6 +568,7 @@ static int init_vo(sh_video_t *sh, enum 
 #ifdef HAVE_XVMC
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
 #endif
 	default:
 	    ctx->best_csp=0;
@@ -969,7 +972,11 @@ int i;
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+        if (avctx->xvmc_acceleration != 4)
         printf("vd_ffmpeg: XVMC accelerated MPEG2\n");
+        else
+            printf("vd_ffmpeg: XVMC-VLD accelerated MPEG2\n");
+
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
--- libvo/vo_xvmc.c	20 Dec 2005 19:04:17 -0000	1.25
+++ libvo/vo_xvmc.c	1 Jan 2006 08:45:40 -0000
@@ -24,6 +24,10 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -115,7 +119,7 @@ static vo_info_t info = {
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 LIBVO_EXTERN(xvmc);
@@ -188,7 +192,23 @@ static void deallocate_xvimage()
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+    return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}            
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+    if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+        if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+        if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+        return 0;
+    }
+#endif
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -467,6 +487,8 @@ static uint32_t vm_height;
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
+if (!hasVLDAcceleration())
+{
    rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
    if( rez != Success ){
       XvMCDestroyContext(mDisplay,&ctx);
@@ -482,6 +504,8 @@ static uint32_t vm_height;
    }
    printf("vo_xvmc: mv_blocks allocated\n");
 
+}
+
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
    memset(surface_render,0,MAX_SURFACES*sizeof(xvmc_render_state_t));
@@ -500,6 +524,11 @@ static uint32_t vm_height;
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+      surface_render[i].state = 0;
+      surface_render[i].disp = mDisplay;
+      surface_render[i].ctx = &ctx;
+
       if( verbose > 3 )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -1134,9 +1163,11 @@ int i;
 
    if( number_of_surfaces ){
 
+      if (!hasVLDAcceleration())
+      {
       XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
       XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1211,6 +1242,17 @@ int rez;
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1222,7 +1264,7 @@ int rez;
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1250,6 +1292,7 @@ int rez;
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1342,8 +1385,16 @@ assert(rndr->next_free_data_block_num ==
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
--- libavcodec/avcodec.h	29 Dec 2005 07:24:23 -0000	1.438
+++ libavcodec/avcodec.h	1 Jan 2006 08:45:44 -0000
@@ -253,6 +253,7 @@ enum PixelFormat {
     PIX_FMT_XVMC_MPEG2_IDCT,
     PIX_FMT_UYVY422,   ///< Packed pixel, Cb Y0 Cr Y1
     PIX_FMT_UYVY411,   ///< Packed pixel, Cb Y0 Y1 Cr Y2 Y3
+    PIX_FMT_XVMC_MPEG2_VLD,
     PIX_FMT_NB,
 };
 
@@ -2113,6 +2114,7 @@ extern AVCodec mpeg1video_decoder;
 extern AVCodec mpeg2video_decoder;
 extern AVCodec mpegvideo_decoder;
 extern AVCodec mpeg_xvmc_decoder;
+extern AVCodec mpeg_xxmc_decoder;
 extern AVCodec h263i_decoder;
 extern AVCodec flv_decoder;
 extern AVCodec rv10_decoder;
--- libavcodec/xvmcvideo.c	22 Dec 2005 01:10:09 -0000	1.13
+++ libavcodec/xvmcvideo.c	1 Jan 2006 08:45:45 -0000
@@ -70,11 +70,68 @@ const int mb_block_count = 4+(1<<s->chro
     }
 }
 
+#ifdef HAVE_XVMC_VLD
+static XvMCSurface* findPastSurface(MpegEncContext *s,
+                                    xvmc_render_state_t *render)
+{
+    Picture *lastp = s->last_picture_ptr;
+    xvmc_render_state_t *last = NULL;
+
+    if (NULL!=lastp) {
+        last = (xvmc_render_state_t*)(lastp->data[2]);
+        if (B_TYPE==last->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Past frame is a B frame in findPastSurface, this is bad.\n");
+        //assert(B_TYPE!=last->pict_type);
+    }
+
+    if (NULL==last)
+        if (!s->first_field)
+            last = render; // predict second field from the first
+        else
+            return 0;
+
+    if (last->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (last->state & MP_XVMC_STATE_PREDICTION) ? last->p_surface : 0;
+}
+
+static XvMCSurface* findFutureSurface(MpegEncContext *s)
+{
+    Picture *nextp = s->next_picture_ptr;
+    xvmc_render_state_t *next = NULL;
+
+    if (NULL!=nextp) {
+        next = (xvmc_render_state_t*)(nextp->data[2]);
+        if (B_TYPE==next->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Next frame is a B frame in findFutureSurface, thisis bad.\n");
+        //assert(B_TYPE!=next->pict_type);
+    }
+
+    assert(NULL!=next);
+
+    if (next->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (next->state & MP_XVMC_STATE_PREDICTION) ? next->p_surface : 0;
+}
+#endif //HAVE_XVMC_VLD
+
 //these functions should be called on every new field or/and frame
 //They should be safe if they are called few times for same field!
 int XVMC_field_start(MpegEncContext*s, AVCodecContext *avctx){
-xvmc_render_state_t * render,* last, * next;
+    xvmc_render_state_t * render, * last, * next;
+
+#ifdef HAVE_XVMC_VLD
+    XvMCMpegControl     binfo;
+    XvMCQMatrix         qmatrix;
+    int                 i;
+    Status              status;
 
+    memset(&binfo, 0, sizeof(binfo));
+    memset(&qmatrix, 0, sizeof(qmatrix));
+#endif
+    
     assert(avctx != NULL);
 
     render = (xvmc_render_state_t*)s->current_picture.data[2];
@@ -85,12 +142,53 @@ xvmc_render_state_t * render,* last, * n
     render->picture_structure = s->picture_structure;
     render->flags = (s->first_field)? 0: XVMC_SECOND_FIELD;
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        if (render->picture_structure == PICT_FRAME)
+            render->flags |= XVMC_FRAME_PICTURE;
+        else if (render->picture_structure == PICT_TOP_FIELD)
+            render->flags |= XVMC_TOP_FIELD;
+        else if (render->picture_structure == PICT_BOTTOM_FIELD)
+            render->flags |= XVMC_BOTTOM_FIELD;
+    }
+    else
+#endif
+    {
 //make sure that all data is drawn by XVMC_end_frame
     assert(render->filled_mv_blocks_num==0);
+    }
 
     render->p_future_surface = NULL;
     render->p_past_surface = NULL;
 
+    render->pict_type = s->pict_type; // for later frame dropping use
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+{
+    switch(s->pict_type){
+        case  I_TYPE:
+            break;
+        case  B_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = findFutureSurface(s);
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and past frame is null!");
+            else if (!render->p_future_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and future frame is null!");
+            break;
+            
+        case  P_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = render->p_surface;
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding P frame and past frame is null!");
+            break;
+    }
+} else
+#endif
+{
     switch(s->pict_type){
         case  I_TYPE:
             return 0;// no prediction from other frames
@@ -111,8 +209,96 @@ xvmc_render_state_t * render,* last, * n
             render->p_past_surface = last->p_surface;
             return 0;
     }
+}
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        for (i = 0; i < 64; i++){
+        qmatrix.intra_quantiser_matrix[i] = s->intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.non_intra_quantiser_matrix[i] = s->inter_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_intra_quantiser_matrix[i] = s->chroma_intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_non_intra_quantiser_matrix[i] = s->chroma_inter_matrix[s->dsp.idct_permutation[i]];
+        }
 
-return -1;
+    qmatrix.load_intra_quantiser_matrix = 1;
+    qmatrix.load_non_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_non_intra_quantiser_matrix = 1;
+
+
+    binfo.flags = 0;
+    if (s->alternate_scan)
+        binfo.flags |= XVMC_ALTERNATE_SCAN;
+    if (s->top_field_first)
+        binfo.flags |= XVMC_TOP_FIELD_FIRST;
+    if (s->frame_pred_frame_dct)
+        binfo.flags |= XVMC_PRED_DCT_FRAME;
+    else
+        binfo.flags |= XVMC_PRED_DCT_FIELD;
+
+    if (s->intra_vlc_format)
+        binfo.flags |= XVMC_INTRA_VLC_FORMAT;
+    if (!s->first_field && !s->progressive_sequence)
+        binfo.flags |= XVMC_SECOND_FIELD;
+    if (s->q_scale_type)
+        binfo.flags |= XVMC_Q_SCALE_TYPE;
+    if (s->concealment_motion_vectors)
+        binfo.flags |= XVMC_CONCEALMENT_MOTION_VECTORS;
+    if (s->progressive_sequence)
+        binfo.flags |= XVMC_PROGRESSIVE_SEQUENCE;
+
+    binfo.picture_structure = s->picture_structure;
+    switch (s->pict_type)
+    {
+    case I_TYPE:    binfo.picture_coding_type = XVMC_I_PICTURE;     break;
+    case P_TYPE:    binfo.picture_coding_type = XVMC_P_PICTURE;     break;
+    case B_TYPE:    binfo.picture_coding_type = XVMC_B_PICTURE;     break;
+    default:    av_log(avctx, AV_LOG_ERROR, "%s: Unknown picture coding type: %d\n", __FUNCTION__, s->pict_type);
+    }
+
+    binfo.intra_dc_precision = s->intra_dc_precision;;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+        binfo.mpeg_coding = 2;
+    else
+        binfo.mpeg_coding = 1;
+
+    s->mb_width = (s->width + 15) / 16;
+    s->mb_height = (s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) ?
+        2 * ((s->height + 31) / 32) : (s->height + 15) / 16;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][1] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][0] - 1);
+}
+else
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][1] - 1);
+}
+
+    status = XvMCLoadQMatrix(render->disp, render->ctx, &qmatrix);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCLoadQMatrix: Error: %d\n", status);
+
+    status = XvMCBeginSurface(render->disp, render->ctx, render->p_surface,
+                              render->p_past_surface, render->p_future_surface,
+                              &binfo);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCBeginSurface: Error: %d\n", status);
+
+    if (!status)
+        return 0;
+    }
+#endif
+
+    return -1;
 }
 
 void XVMC_field_end(MpegEncContext *s){
@@ -120,10 +306,22 @@ xvmc_render_state_t * render;
     render = (xvmc_render_state_t*)s->current_picture.data[2];
     assert(render != NULL);
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        XvMCFlushSurface(render->disp, render->p_surface);
+        XvMCSyncSurface(render->disp, render->p_surface);
+
+    	s->error_count = 0;
+    }
+    else
+#endif
+    {
     if(render->filled_mv_blocks_num > 0){
 //        printf("xvmcvideo.c: rendering %d left blocks after last slice!!!\n",render->filled_mv_blocks_num );
         ff_draw_horiz_band(s,0,0);
     }
+    }
 }
 
 void XVMC_decode_mb(MpegEncContext *s){
@@ -313,4 +511,50 @@ const int mb_xy = s->mb_y * s->mb_stride
 
 }
 
+#ifdef HAVE_XVMC_VLD
+static int length_to_next_start(uint8_t* pbuf_ptr, int buf_size)
+{
+    uint8_t*    buf_ptr;
+    unsigned int    state = 0xFFFFFFFF, v;
+
+    buf_ptr = pbuf_ptr;
+    while (buf_ptr < pbuf_ptr + buf_size)
+    {
+        v = *buf_ptr++;
+        if (state == 0x000001) {
+            return buf_ptr - pbuf_ptr - 4;
+        }
+        state = ((state << 8) | v) & 0xffffff;
+    }
+    return -1;
+}
+
+#define SLICE_MIN_START_CODE   0x00000101
+#define SLICE_MAX_START_CODE   0x000001af
+
+void XVMC_decode_slice(MpegEncContext *s, int mb_y, uint8_t* buffer, int buf_size)
+{
+    int slicelen = length_to_next_start(buffer, buf_size);
+    xvmc_render_state_t*    render;
+
+    if (slicelen < 0)
+    {
+        if ((mb_y == s->mb_height - 1) || 
+            (!s->progressive_sequence && mb_y == (s->mb_height >> 1) -1) ||
+	    (s->codec_id != CODEC_ID_MPEG2VIDEO))
+            slicelen = buf_size;
+        else
+            return;
+    }
+
+    render = (xvmc_render_state_t*)s->current_picture.data[2];
+    render->slice_code = SLICE_MIN_START_CODE + mb_y;
+    render->slice_data = buffer;
+    render->slice_datalen = slicelen;
+
+    ff_draw_horiz_band(s, 0, 0);
+}
 #endif
+
+#endif
+
--- libavcodec/allcodecs.c	2006-02-01 23:04:31.931705000 +0100
+++ libavcodec/allcodecs.c	2006-02-01 23:05:33.760775000 +0100
@@ -138,6 +138,9 @@
     register_avcodec(&mpeg1video_decoder);
     register_avcodec(&mpeg2video_decoder);
     register_avcodec(&mpegvideo_decoder);
+#ifdef HAVE_XVMC_VLD
+    register_avcodec(&mpeg_xxmc_decoder);
+#endif
 #ifdef HAVE_XVMC
     register_avcodec(&mpeg_xvmc_decoder);
 #endif
--- libavcodec/mpeg12.c	2006-02-01 23:22:48.353926000 +0100
+++ libavcodec/mpeg12.c	2006-02-01 23:21:06.863926000 +0100
@@ -82,10 +82,16 @@
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 #endif
 
+#ifdef HAVE_XVMC_VLD
+extern int XVMC_decode_slice(MpegEncContext *s, int start_code,
+		uint8_t *buffer, int buf_size);
+#endif
+
 const enum PixelFormat pixfmt_yuv_420[]= {PIX_FMT_YUV420P,-1};
 const enum PixelFormat pixfmt_yuv_422[]= {PIX_FMT_YUV422P,-1};
 const enum PixelFormat pixfmt_yuv_444[]= {PIX_FMT_YUV444P,-1};
 const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
+					   PIX_FMT_XVMC_MPEG2_VLD,
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
 					   -1};
@@ -2432,6 +2438,16 @@
         av_log(s->avctx, AV_LOG_ERROR, "slice below image (%d >= %d)\n", mb_y, s->mb_height);
         return -1;
     }
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4){
+	    int used = XVMC_decode_slice(s, mb_y, *buf, buf_size);
+	    if (used < 0)
+		    return DECODE_SLICE_ERROR;
+	    *buf += used - 1;
+	    return DECODE_SLICE_OK;
+    }
+#endif
     
     init_get_bits(&s->gb, *buf, buf_size*8);
 
@@ -3206,6 +3222,43 @@
 
 #endif
 
+
+#ifdef HAVE_XVMC_VLD
+static int mpeg_xxmc_decode_init(AVCodecContext *avctx){
+    Mpeg1Context *s;
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) )
+        dprintf("mpeg12.c: XVMC_VLD decoder will work better if SLICE_FLAG_ALLOW_FIELD is set\n");
+
+    mpeg_decode_init(avctx);
+    s = avctx->priv_data;
+
+    avctx->pix_fmt = PIX_FMT_XVMC_MPEG2_VLD;
+    avctx->xvmc_acceleration = 4;
+
+    return 0;
+}
+
+AVCodec mpeg_xxmc_decoder = {
+    "mpegvideo_xvmc",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEG2VIDEO_XVMC,
+    sizeof(Mpeg1Context),
+    mpeg_xxmc_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED| CODEC_CAP_HWACCEL,
+    .flush= ff_mpeg_flush,
+};
+
+#endif
+
+
+
 /* this is ugly i know, but the alternative is too make 
    hundreds of vars global and prefix them with ff_mpeg1_
    which is far uglier. */
